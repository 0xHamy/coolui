<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Hexagonal Network with Glowing Borders and Overlay</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const aspectRatio = window.innerWidth / window.innerHeight;
        const frustumHeight = 20;
        const frustumWidth = frustumHeight * aspectRatio;
        const camera = new THREE.OrthographicCamera(
            -frustumWidth / 2, frustumWidth / 2,
            frustumHeight / 2, -frustumHeight / 2,
            0.1, 1000
        );
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Hexagon geometry function (for lines)
        function createHexagon(radius) {
            const points = [];
            const sides = 6;
            for (let i = 0; i <= sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                points.push(new THREE.Vector3(x, y, 0));
            }
            return points;
        }

        // Random color array
        const colors = [0x800080, 0x0000FF, 0x00FFFF, 0xFF69B4]; // Purple, Blue, Cyan, Pink

        // Store hexagons and their properties
        const hexagons = [];
        const numHexagons = 30;

        // Function to check for collisions
        function isPositionValid(pos, radius, existingHexagons) {
            for (const hex of existingHexagons) {
                const dist = Math.sqrt(
                    Math.pow(pos.x - hex.position.x, 2) +
                    Math.pow(pos.y - hex.position.y, 2)
                );
                if (dist < (radius + hex.radius + 0.8)) {
                    return false;
                }
            }
            return true;
        }

        // Create hexagons with double borders and glowing effect
        for (let i = 0; i < numHexagons; i++) {
            const radius = Math.random() * 0.5 + 0.5;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.8,
                linewidth: 2
            });

            const glowMaterial = new THREE.LineBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.3,
                linewidth: 4
            });

            // Outer border
            const outerPoints = createHexagon(radius);
            const outerGeometry = new THREE.BufferGeometry().setFromPoints(outerPoints);
            const outerLine = new THREE.Line(outerGeometry, lineMaterial);

            // Inner border
            const innerPoints = createHexagon(radius * 0.9);
            const innerGeometry = new THREE.BufferGeometry().setFromPoints(innerPoints);
            const innerLine = new THREE.Line(innerGeometry, lineMaterial);

            // Glow effect (outer)
            const glowPoints = createHexagon(radius * 1.1);
            const glowGeometry = new THREE.BufferGeometry().setFromPoints(glowPoints);
            const glowLine = new THREE.Line(glowGeometry, glowMaterial);

            // Glow effect (inner)
            const innerGlowPoints = createHexagon(radius * 0.95);
            const innerGlowGeometry = new THREE.BufferGeometry().setFromPoints(innerGlowPoints);
            const innerGlowLine = new THREE.Line(innerGlowGeometry, glowMaterial);

            // Group the borders and glow effects
            const hexagonGroup = new THREE.Group();
            hexagonGroup.add(glowLine);
            hexagonGroup.add(outerLine);
            hexagonGroup.add(innerGlowLine);
            hexagonGroup.add(innerLine);

            let pos;
            let attempts = 0;
            const maxAttempts = 100;

            do {
                pos = new THREE.Vector3(
                    (Math.random() - 0.5) * frustumWidth * 0.9,
                    (Math.random() - 0.5) * frustumHeight * 0.9,
                    0
                );
                attempts++;
            } while (!isPositionValid(pos, radius, hexagons) && attempts < maxAttempts);

            if (attempts >= maxAttempts) continue;

            hexagonGroup.position.copy(pos);
            hexagonGroup.radius = radius;
            hexagonGroup.basePosition = pos.clone();
            hexagons.push(hexagonGroup);
            scene.add(hexagonGroup);
        }

        // Create complex lines between hexagons
        for (let i = 0; i < hexagons.length; i++) {
            const hex1 = hexagons[i];
            const numConnections = Math.floor(Math.random() * 3) + 4;
            const distances = hexagons.map((hex2, idx) => ({
                idx: idx,
                dist: hex1.position.distanceTo(hex2.position)
            })).sort((a, b) => a.dist - b.dist).slice(1, numConnections + 1);

            distances.forEach(({ idx }) => {
                const hex2 = hexagons[idx];
                const lineOpacity = Math.random() * 0.3 + 0.1;
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x00FFFF, 
                    transparent: true, 
                    opacity: lineOpacity,
                    linewidth: Math.random() * 2 + 1
                });
                const points = [hex1.position, hex2.position];
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);

                if (Math.random() > 0.5) {
                    const offset = 0.1;
                    const offsetPoints = [
                        new THREE.Vector3(
                            hex1.position.x + (Math.random() - 0.5) * offset,
                            hex1.position.y + (Math.random() - 0.5) * offset,
                            0
                        ),
                        new THREE.Vector3(
                            hex2.position.x + (Math.random() - 0.5) * offset,
                            hex2.position.y + (Math.random() - 0.5) * offset,
                            0
                        )
                    ];
                    const secondaryLineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x00FFFF, 
                        transparent: true, 
                        opacity: lineOpacity * 0.5,
                        linewidth: 1
                    });
                    const secondaryLineGeometry = new THREE.BufferGeometry().setFromPoints(offsetPoints);
                    const secondaryLine = new THREE.Line(secondaryLineGeometry, secondaryLineMaterial);
                    scene.add(secondaryLine);
                }
            });
        }

        // Add glowing dots at hexagon centers
        const dotMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.2, transparent: true, opacity: 0.8 });
        const dotGeometry = new THREE.BufferGeometry();
        const positions = [];
        hexagons.forEach(hex => {
            positions.push(hex.position.x, hex.position.y, hex.position.z);
        });
        dotGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const dots = new THREE.Points(dotGeometry, dotMaterial);
        scene.add(dots);

        // Create transparent black overlay
        const overlayGeometry = new THREE.PlaneGeometry(frustumWidth, frustumHeight);
        const overlayMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.7 // Initial opacity (adjustable)
        });
        const overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);
        overlay.position.z = 5; // Place in front of hexagons but behind camera
        scene.add(overlay);

        // Functions to adjust overlay opacity
        function increaseOpacity() {
            overlayMaterial.opacity = Math.min(overlayMaterial.opacity + 0.1, 1);
            console.log('Overlay opacity:', overlayMaterial.opacity);
        }

        function decreaseOpacity() {
            overlayMaterial.opacity = Math.max(overlayMaterial.opacity - 0.1, 0);
            console.log('Overlay opacity:', overlayMaterial.opacity);
        }

        // Add keyboard controls to adjust opacity
        window.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowUp') {
                increaseOpacity();
            } else if (event.key === 'ArrowDown') {
                decreaseOpacity();
            }
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            // Animate hexagons with smooth movement
            hexagons.forEach((hex, i) => {
                hex.position.x = hex.basePosition.x + Math.sin(Date.now() * 0.001 + i) * 0.3;
                hex.position.y = hex.basePosition.y + Math.cos(Date.now() * 0.001 + i) * 0.3;
                hex.rotation.z += 0.005;
            });

            // Update dot positions to match hexagons
            const dotPositions = dotGeometry.attributes.position.array;
            hexagons.forEach((hex, i) => {
                dotPositions[i * 3] = hex.position.x;
                dotPositions[i * 3 + 1] = hex.position.y;
                dotPositions[i * 3 + 2] = hex.position.z;
            });
            dotGeometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const aspectRatio = window.innerWidth / window.innerHeight;
            const frustumWidth = frustumHeight * aspectRatio;
            camera.left = -frustumWidth / 2;
            camera.right = frustumWidth / 2;
            camera.top = frustumHeight / 2;
            camera.bottom = -frustumHeight / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update overlay size on resize
            overlay.geometry.dispose();
            overlay.geometry = new THREE.PlaneGeometry(frustumWidth, frustumHeight);
        });

        // Log instructions for user
        console.log('Use Arrow Up to increase overlay opacity (less visible), Arrow Down to decrease (more visible)');
    </script>
</body>
</html>