<!DOCTYPE html>
<html>
<head>
    <title>Glitch Animation</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Initialization Parameters
        const config = {
            lineThickness: 20,           // Line thickness in pixels
            minLines: 20,               // Minimum number of lines at a time
            maxLines: 30,              // Maximum number of lines at a time
            minLength: 500,             // Minimum length of lines in pixels
            maxLength: 800,             // Maximum length of lines in pixels
            speed: 1,                   // Speed of appearance/disappearance (0 to 1, higher is faster)
            proximity: 0.1,             // Proximity factor (0 to 1, 0 = fully dispersed, 1 = tightly clustered)
            glitch: {
                segments: 5,            // Number of segments to break the line into (higher = more broken)
                flickerSpeed: 20,       // Speed of flickering (higher = faster flicker)
                duration: 0.5,          // Duration of the glitch effect in seconds
                offsetRange: 10         // Max pixel offset for segments (higher = more chaotic displacement)
            }
        };

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -2, 
            window.innerWidth / 2, 
            window.innerHeight / 2, 
            window.innerHeight / -2, 
            1, 1000
        );
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Array to store lines
        const lines = [];

        // Function to create a new line with segmented glitch effect
        function createLine() {
            // Random length between minLength and maxLength
            const length = Math.random() * (config.maxLength - config.minLength) + config.minLength;

            // Create segments for the line
            const segmentLength = length / config.glitch.segments;
            const segments = [];

            for (let i = 0; i < config.glitch.segments; i++) {
                const geometry = new THREE.BufferGeometry();
                const start = i * segmentLength;
                const end = (i + 1) * segmentLength;
                const vertices = new Float32Array([
                    start, 0, 0,  // Start point of segment
                    end, 0, 0     // End point of segment
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

                // Create material for each segment
                const material = new THREE.LineBasicMaterial({
                    color: 0xff0000,
                    linewidth: config.lineThickness,
                    transparent: true,
                    opacity: 0 // Start with 0 opacity
                });

                const segment = new THREE.Line(geometry, material);
                segments.push({
                    mesh: segment,
                    offset: { x: 0, y: 0 }, // For glitch displacement
                    flicker: Math.random() // Random flicker phase
                });
            }

            // Create a group to hold all segments
            const lineGroup = new THREE.Group();
            segments.forEach(segment => lineGroup.add(segment.mesh));

            // Position based on proximity
            let x, y;
            if (config.proximity === 0) {
                // Fully dispersed
                x = Math.random() * window.innerWidth - window.innerWidth / 2;
                y = Math.random() * window.innerHeight - window.innerHeight / 2;
            } else {
                // Cluster around a random point
                const clusterX = (Math.random() * window.innerWidth - window.innerWidth / 2);
                const clusterY = (Math.random() * window.innerHeight - window.innerHeight / 2);
                const offsetX = (Math.random() - 0.5) * window.innerWidth * config.proximity;
                const offsetY = (Math.random() - 0.5) * window.innerHeight * config.proximity;
                x = clusterX + offsetX;
                y = clusterY + offsetY;
            }
            lineGroup.position.set(x, y, 0);

            // Add to scene and lines array
            scene.add(lineGroup);
            lines.push({
                group: lineGroup,
                segments: segments,
                lifetime: Math.random() * 0.5 + 0.2, // Base lifetime between 0.2 to 0.7 seconds
                opacity: 0,
                fadingIn: true,
                glitchTimer: 0,
                isGlitching: true
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Ensure minimum number of lines
            const targetLines = Math.random() * (config.maxLines - config.minLines) + config.minLines;
            if (lines.length < targetLines && Math.random() < 0.1) { // 10% chance per frame
                createLine();
            }

            // Update lines
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i];

                // Handle opacity for smooth appearance/disappearance
                if (line.fadingIn) {
                    line.opacity += config.speed * 0.05;
                    if (line.opacity >= 1) {
                        line.opacity = 1;
                        line.fadingIn = false;
                        line.isGlitching = false; // Stop glitching once fully faded in
                    }
                } else {
                    line.lifetime -= 0.016; // Roughly 60 FPS
                    if (line.lifetime <= 0) {
                        line.opacity -= config.speed * 0.05;
                    }
                }

                // Glitch effect during fade-in
                if (line.isGlitching) {
                    line.glitchTimer += 0.016; // Increment timer
                    if (line.glitchTimer >= config.glitch.duration) {
                        line.isGlitching = false; // Stop glitching after duration
                    }

                    // Update each segment
                    line.segments.forEach(segment => {
                        // Flicker effect
                        segment.flicker += 0.016 * config.glitch.flickerSpeed;
                        const flicker = Math.sin(segment.flicker) > 0 ? line.opacity : 0;
                        segment.mesh.material.opacity = flicker;

                        // Random displacement for glitch effect
                        if (line.isGlitching) {
                            segment.offset.x = (Math.random() - 0.5) * config.glitch.offsetRange;
                            segment.offset.y = (Math.random() - 0.5) * config.glitch.offsetRange;
                        } else {
                            segment.offset.x = 0;
                            segment.offset.y = 0;
                        }
                        segment.mesh.position.set(segment.offset.x, segment.offset.y, 0);
                    });
                } else {
                    // Apply opacity to all segments when not glitching
                    line.segments.forEach(segment => {
                        segment.mesh.material.opacity = line.opacity;
                        segment.mesh.position.set(0, 0, 0); // Reset position
                    });
                }

                // Remove line if fully faded out
                if (line.opacity <= 0 && !line.fadingIn) {
                    scene.remove(line.group);
                    line.segments.forEach(segment => {
                        segment.mesh.geometry.dispose();
                        segment.mesh.material.dispose();
                    });
                    lines.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start the animation
        animate();
    </script>
</body>
</html>